// The used board is Arduino Mega 

const byte Pot_PIN = A0; // analog pin used to connect the potentiometer
////
const byte PWM_PIN = 10;        // PWM To Motordriver  (PWM)
const byte MotorDirection = 51;    //     To Motordriver  (Direction)
////
const byte Encod_A = 52;   //for encoder pulse A   From Encoder
const byte Encod_B = 53;   //for encoder pulse B   From Encoder
//////////////////////////////////////////////////
int PotVal;        // variable to read the value2 from the analog pin2
int PwmVal;        // variable to set the value of the PWM signal 
//////////////////////////////////////////////////
String mySt = "";
char myChar;
boolean stringComplete = false;  // whether the string is complete
boolean motor_start = false;

int encoder = 0;
int m_direction = 0;
int sv_speed = 100;     //this value is 0~255
double pv_speed = 0;
double set_speed = 0;
double e_speed = 0; //error of speed = set_speed - pv_speed
double e_speed_pre = 0;  //last error of speed
double e_speed_sum = 0;  //sum error of speed
double pwm_pulse = 0;     //this value is 0~255
double kp = 0;
double ki = 0;
double kd = 0;
int timer1_counter; //for timer
int i=0;
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
void setup()  { 
    Serial.begin(9600);       // start serial port at 9600 bps:
    //
    pinMode(Encod_A, INPUT_PULLUP);     //   the type of mode in which the digital pin is set to the HIGH level.
    pinMode(Encod_B, INPUT_PULLUP);     //   the type of mode in which the digital pin is set to the HIGH level.
    //
    pinMode(MotorDirection, OUTPUT);
    pinMode(PWM_PIN, OUTPUT); // declare pin 10 to be an output:
    analogWrite(PWM_PIN, 0);  // start with no output on PWMpin
    attachInterrupt(digitalPinToInterrupt(Encod_A), detect_a, RISING);
    
    //--------------------------timer setup
    noInterrupts();           // disable all interrupts
    TCCR1A = 0;  // Clear Timer1 Control Register A
    TCCR1B = 0;  // Clear Timer1 Control Register B
    timer1_counter = 59286;   // preload timer 65536-16MHz/256/2Hz (34286 for 0.5sec) (59286 for 0.1sec)
  
    TCNT1 = timer1_counter;   // preload timer
    TCCR1B |= (1 << CS12);    // 256 prescaler 
    TIMSK1 |= (1 << TOIE1);   // enable timer overflow interrupt
    interrupts();             // enable all interrupts
    //--------------------------timer setup
    while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
} 
/////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

void loop()  { 
  if (stringComplete) {
    // clear the string when COM receiving is completed
    mySt = "";  //note: in code below, mySt will not become blank, mySt is blank until '\n' is received
    stringComplete = false;
  }
     digitalWrite(MotorDirection, LOW);                

  PotVal = analogRead(Pot_PIN);       // reads the value of potentiometer2 (value between 0 and 1023) 
  
  if (PotVal >= 0 and PotVal <= 1023) {      // motor rotating one direction
  PwmVal = map(PotVal, 0, 1023, 255, 0);  // motor rotating in one direction slow to highest rpm
  analogWrite(PWM_PIN, PwmVal);              // writes PWM value to digital pin
  Serial.print("Pot_speed");
  Serial.println(PwmVal, DEC);
  }
}


void detect_a() {
  encoder+=1; //increasing encoder at new pulse
  m_direction = digitalRead(Encod_B); //read direction of motor
}

ISR(TIMER1_OVF_vect)        // interrupt service routine - tick every 0.1sec
{
  TCNT1 = timer1_counter;   // set timer
  pv_speed = 60.0*(encoder/24.0)/0.1;  //calculate motor speed, unit is rpm
  encoder=0;
  //print out speed
  if (Serial.available() <= 0) {
    Serial.print("speed");
    Serial.println(pv_speed);         //Print speed (rpm) value to Visual Studio
    }


  //PID program
  if (motor_start){
    e_speed = set_speed - pv_speed;
    pwm_pulse = e_speed*kp + e_speed_sum*ki + (e_speed - e_speed_pre)*kd;
    e_speed_pre = e_speed;  //save last (previous) error
    e_speed_sum += e_speed; //sum of error
    if (e_speed_sum >4000) e_speed_sum = 4000;
    if (e_speed_sum <-4000) e_speed_sum = -4000;
  }
  else{
    e_speed = 0;
    e_speed_pre = 0;
    e_speed_sum = 0;
    pwm_pulse = 0;
  }
  

  //update new speed
  if (pwm_pulse <255 & pwm_pulse >0){
    analogWrite(PWM_PIN,pwm_pulse);  //set motor speed  
  }
  else{
    if (pwm_pulse>255){
      analogWrite(PWM_PIN,255);
    }
    else{
      analogWrite(PWM_PIN,0);
    }
  }
  
}
void serialEvent() {
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    if (inChar != '\n') {
      mySt += inChar;
    }
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
}
